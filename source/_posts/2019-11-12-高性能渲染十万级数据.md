---
title: 高性能渲染十万级数据
author: Dovis
top: true
cover: false
date: 2019-11-12 16:21:32
password:
summary: 如果遇到需要一次性向页面插入大量数据的情况，并且不能让页面卡的情况下渲染，那么该如何做呢？
tags: 
    - 时间分片
    - 虚拟列表
    - 超高数量级数据量
categories:
    - 前端进阶
---
### 前言
对于一次性插入大量数据的情况，一般有两种做法：
1. 时间分片
2. 虚拟列表

接下来将分别介绍如何使用’时间分片‘及’虚拟列表‘的方式来渲染大量数据

### 一次性渲染（最容易想到的极其粗暴的方法）
```javascript
<ul id="container">

</ul>
<script>
    // 记录任务开始时间
    let now = Date.now()
    // 插入十万条数据
    const total = 100000
    // 获取容器
    let ul = document.getElementById('container')
    //将数据插入到容器中
    for(let i=0;i<total;i++){
        let li = document.createElement('li')
        li.innerText = Math.random()*total
        ul.appendChild(li)
    }
    console.log('js运行时间:', Date.now() - now) // 162ms
    setTimeout(() => {
        console.log('总运行时间：', Date.now() - now) // 2887ms
    },0)
</script>
```

简单说明一下，为何两次console.log的结果时间差异巨大，并且是如何简单统计JS运行时间和总渲染时间：
- 在JS的事件队列Event Loop中，当JS引擎所在管理当执行栈中当事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染
- 第一个console.log的触发时间是中页面进行渲染之前，此时得到的间隔时间为JS运行所需要的时间
- 第二个console.log是放到定时器中，他的触发时间是在渲染完成，在下一次事件队列中执行的

可以得出的结论：对于大量数据渲染的时候，JS运算并不是性能的瓶颈，性能的瓶颈主要在于渲染阶段

**关于Event Loop更多知识点可以参考：[]()**

### 使用定时器
从上面简单粗暴的例子可以看出页面的渲染耗时长是由于同时渲染大量DOM所引起的，所以我们考虑将渲染过程分批进行

```javascript
let ul = document.getElementById('container')
// 插入十万条数据
let total = 100000
//一次插入20条
let once = 20;
//总页数
let page = total/once
//每条记录的索引
let index = 0;
//循环加载数据
function loop(curTotal,curIndex){
 if(curTotal<=0){
    return false;
 }
  //每页多少条
 let pageCount = Math.min(curTotal, once)
  setTimeout(() => {
  for(let i=0;i<pageCount;i++){
       let li = document.createElement('li')
        li.innerText = curIndex + i + ':' + ~~(Math.random()*total)
        ul.appendChild(li)
    }
        loop(curTotal - pageCount,curIndex+pageCount)
    },0)
  }
 loop(total,index)
```
